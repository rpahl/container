% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rename.R
\name{rename}
\alias{rename}
\alias{rename_}
\alias{rename.Dict}
\alias{rename_.Dict}
\alias{rename.dict.table}
\alias{rename_.dict.table}
\title{Rename elements safely}
\usage{
rename(.x, old, new, ...)

rename_(.x, old, new, ...)

\method{rename}{Dict}(.x, old, new)

\method{rename_}{Dict}(.x, old, new)

\method{rename}{dict.table}(.x, old, new, ...)

\method{rename_}{dict.table}(.x, old, new, ...)
}
\arguments{
\item{.x}{any \code{R} object with names.}

\item{old}{\code{character} vector of old names.}

\item{new}{\code{character} vector of new names.}

\item{...}{additional arguments to be passed to or from methods.}
}
\value{
For standard \code{R} vectors renames \code{old} to \code{new} and returns the
renamed vector.

For \code{Dict} renames key \code{old} to \code{new} in place (i.e. by reference)
and invisibly returns the \code{\link[=Dict]{Dict()}} object.

For \code{dict.table} renames key \code{old} to \code{new} in place (i.e. by
reference) and invisibly returns the \code{\link[=dict.table]{dict.table()}} object.
}
\description{
Search for old name and replace it by new name. If either the
old name does not exist or the name would result in a name-clash with an
already existing name, an error is signaled.
}
\details{
The passed old and new names can be vectors but always must have
the same length and must be unique to prevent double-renaming.

\code{rename} uses copy semantics while \code{rename_} works by reference.
}
\examples{

# Dict
d = dict(a = 1, b = 2, c = 3)
(rename(d, c("a", "b"), c("a1", "y")))

# dict.table
dit = dict.table(a = 1, b = 2, c = 3)
(rename(dit, c("a", "b"), c("a1", "y")))
rename_(dit, c("a", "b"), c("a1", "y"))
print(dit)
}
