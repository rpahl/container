% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DictS3.R, R/GroupGenericMath.R,
%   R/GroupGenericSummary.R, R/Ops-arithmetic.R, R/Ops-logic.R, R/add.R,
%   R/delete.R, R/discard.R, R/get_at.R, R/peek.R, R/rename.R, R/replace.R,
%   R/update.R
\name{DictS3}
\alias{DictS3}
\alias{dict}
\alias{as.dict}
\alias{is.dict}
\alias{OpsMath}
\alias{OpsSummary}
\alias{OpsArith}
\alias{OpsLogic}
\alias{DictS3methods}
\alias{add.Dict}
\alias{delete.Dict}
\alias{discard.Dict}
\alias{get_at.Dict}
\alias{peek.Dict}
\alias{rename.Dict}
\alias{replace.Dict}
\alias{update.Dict}
\title{Dict methods}
\usage{
dict(...)

as.dict(x)

is.dict(x)

## Dict S3 methods

add(.x, ...)
add_(.x, ...)

delete(.x, ...)
delete(.x, ...)

discard(.x, ...)
discard_(.x, ...)

get_at(.x, ...)

peek(x, key, default)

rename(.x, old, new)
rename_(.x, old, new)

replace(.x, key, value, add = FALSE)
replace_(.x, key, value, add = FALSE)

update(x, other)
update_(x, other)
}
\arguments{
\item{...}{elements put into the \code{Dict}.}

\item{x, y}{\code{R} object of \code{ANY} type for \code{\link[=as.dict]{as.dict()}} and \code{\link[=is.dict]{is.dict()}}
or of class \code{Dict} for the \code{S3} methods.}

\item{key}{\code{character} name of key.}

\item{value}{\code{any} R object}

\item{add}{\code{logical} if \code{FALSE} (default) and \code{key} was not found,
an error is given. In contrast, if set to \code{TRUE} the \code{value} is added
regardless of whether it is used as a replacement for an existing or
added as a new value, respectively.}

\item{other}{another \code{Dict} object}
}
\description{
The \code{\link[=dict]{dict()}} resembles Python's dict type, and is implemented
as a specialized associative \code{\link[=Container]{Container()}} thus sharing all \link[=Container]{container()}
methods with some of them being overridden to account for the associative
key-value pair semantic.
}
\details{
For a full list of all dict methods see \code{\link[=Dict]{Dict()}}.

Methods that alter \code{Dict} objects usually come in two versions
providing either copy or reference semantics where the latter are visible
by an underscore appended to the standard function name, for example,
\verb{[delete()]} and \verb{[delete_()]}.
\subsection{Methods}{
}

\itemize{
\item \code{dict(...)} initializes and returns an object of class \code{Dict}
}

\itemize{
\item \code{as.dict(x)} coerces \code{x} to a dictionary
}

\itemize{
\item \code{is.dict(x)} returns \code{TRUE} if \code{x} is of class \code{Dict}
and \code{FALSE} otherwise.
}

\itemize{
\item \code{x + y} combines \code{x} and \code{y} into a new dict by updating \code{x}
by \code{y} (see also \verb{[update()]}).
}

\itemize{
\item \code{x - y} removes all keys from \code{x} that appear in \code{y}.
}

\itemize{
\item \code{x} \code{&} \code{y} returns a copy of \code{x} keeping only the keys that
are common in both (key intersection), that is, all keys in \code{x} that do not
exist in \code{y} are removed.
}

\itemize{
\item \code{x} \code{|} \code{y} returns a copy of \code{x} extended by all elements of
\code{y} that are stored at keys (or names) that do not exist in \code{x}, thereby
combining the keys of both objects (set union of keys).
}

\itemize{
\item \code{add(.x, ...)} adds \code{key = value} pairs to \code{.x}. If one of the
keys already exists, an error is given.
\item \code{add_(.x, ...)} same as \code{add(.x, ...)} but adds by reference.
}

\itemize{
\item \code{delete(.x, ...)} and \code{delete_(.x, ...)} find and remove values at given
keys. Keys that don't exist are ignored.
}

\itemize{
\item \code{discard(.x, ...)} and \code{discard_(.x, ...)} find and remove values at given
keys. Keys that don't exist are ignored.
}

\itemize{
\item \code{get_at(.x, ...)} retrieves values at given keys. If a \code{key} does not
exist, an error is given.
}

\itemize{
\item \code{peek(x, key, default)} returns the associated value if \code{key} does exists,
otherwise the given \code{default} value.
}

\itemize{
\item \code{rename(.x, old, new)} and \code{rename_(.x, old, new)} rename one or more keys
from \code{old} to \code{new}, respectively, by copy and in place (i.e. by reference).
}

\itemize{
\item \code{replace(.x, key, value, add = FALSE)} and
\code{replace_(.x, key, value, add = FALSE)} replace value at \code{key}.
If \code{key} does not exist, an error is given unless \code{add} was set to \code{TRUE}.
}

\itemize{
\item \code{update(x, other)} and \code{update_(x, other)} adds elements of \code{other} dict
for keys not yet in \code{x} and replaces the values of existing keys.
}
}
\examples{
d = dict(a = 1, b = "one", f = mean, na = NA)
print(d)
names(d)
as.list(d)
na.omit(d)
na.omit(as.list(d)) # does not work with lists

\dontrun{
dict(a = 1, 2)   # all elements must be named}

# Coercion
as.dict(list(A = 1:3, B = "b"))
as.dict(c(x = 1, y = "x", z = 2 + 3))

# Math
set.seed(123)
d = dict(a = rnorm(1), b = rnorm(1))
abs(d)
cumsum(d)
round(d)
exp(d)

# Summary
range(d)
min(d)
max(d)

d1 = dict(a = 1, b = list(1, 2))
d2 = dict(a = 2, b = list(1, 2))
d1 + d2      # same as update(d, d2)
d2 + d1      # same as update(d2, d)
\dontrun{
c(d1, d2)    # duplicated keys are not allowed for Dict}
d - d2
d2 - d
d - d

d1 = dict(a = 1, b = 2)
d2 = dict(a = 10, x = 4)
d1 & d2      # {a = 1}
d1 | d2      # {a = 1, b = 2, x = 4}

d = dict(a = 1)
add(d, b = 2, co = container(1:3))

\dontrun{
add(d, a = 7:9)  # key 'a' already in Dict}

d = dict(a = 1, b = 2)
delete(d, "a", "b")
delete(d, c("a", "b"))
\dontrun{
delete(d, "c")   # key 'c' not in Dict}

d = dict(a = 1, b = 2)
discard(d, "a", "b")
discard(d, c("a", "b"))
discard(d, "c")          # ignored

d = dict(a = 1, b = 1:3)
get_at(d, "b")
get_at(d, "a", "b")      # or alternatively:
get_at(dit, c("a", "b"))
\dontrun{
get_at(d, "z")   # key 'z' not in Dict}

d = dict(a = 1, b = 1:3)
peek(d, "b")
peek(d, "x")
peek(d, "x", default = 4:7)
d = dict(a = 1, b = 2, c = 3)
(rename(d, c("a", "b"), c("a1", "y")))

d = dict(a = 1)
replace(d, "a", 1:5)
\dontrun{
replace(d, "b", 2)              # key 'b' not in Dict}
replace(d, "b", 2, add = TRUE)  # ok, adds value

d1 = dict(a = 1, b = 2)
d2 = dict(       b = 0, c = 3)
update(d1, d2)  # {a = 1, b = 0, c = 3}
update(d2, d1)  # {a = 1, b = 2, c = 3}
}
\seealso{
See \code{\link[=container]{container()}} for all inherited methods. For the full class
documentation see \code{\link[=Dict]{Dict()}} and it's superclass \link[=container]{Container()}.
}
