% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Ops-extract.R
\name{OpsExtract}
\alias{OpsExtract}
\alias{[.Container}
\alias{[[.Container}
\title{Extract Parts of a Container Object}
\usage{
\method{[}{Container}(
  x,
  i,
  ...,
  .default = NULL,
  strict = getOption("container.strict_index", FALSE)
)

\method{[[}{Container}(x, i)
}
\arguments{
\item{x}{\code{Container} object from which to extract elements.}

\item{i, ...}{indices specifying elements to extract. Indices
can be \code{logical}, \code{numeric}, \code{character}, or a mix of these.
They can be passed as \code{vector}, \code{list}, or comma-separated
sequence.
Non-existing indices are ignored, but can be substituted if a
default value was provided (see \code{.default} parameter).
Supports alpha-numeric range selection via non-standard evaluation
(e.g., \code{co[a:b]} see Examples).}

\item{.default}{value to be returned if peeked value does not exist.}
}
\description{
Extract parts of a \code{Container} object similar
to R's base extract operators on lists.
}
\details{
\code{[} selects multiple values. The indices can be \code{numeric} or
\code{character} or both. They can be passed as a \code{vector} or \code{list} or,
for convenience, just as a comma-separated sequence (see Examples).
Non-existing indices are ignored.

\code{[[} selects a single value using a \code{numeric} or \code{character} index.
}
\section{Warning}{

Alpha-numeric range selection (e.g. \code{co[a:b]}) is intended for
interactive use only, because the non-standard evaluation of the
range arguments can have unanticipated consequences.
For programming it is therefore better to use the standard subsetting
indices (e.g. \code{co[1:2]} or \code{co[c("a", "b")]}).
}

\examples{
co <- container(a = 1, b = 2, c = 3, d = 4)

# Numeric
co[c(1, 4)]                          # [a = 1, d = 4]
co[1, 4]                             # same
co[0:5]                              # [a = 1, b = 2, c = 3, d = 4]
co[5]                                # []

# Negative numeric
co[-c(1:2)]                          # [c = 3, d = 4]
co[-1, -4]                           # [b = 2, c = 3]
try(co[-1, 3])                       # cannot mix positive and negative indices

# Character
co[c("a", "d")]                      # [a = 1, d = 4]
co["a", "d"]                         # same
co[letters[1:5]]                     # [a = 1, b = 2, c = 3, d = 4]
co["x"]                              # []

# Negative character
co[-c("a", "d")]                      # [b = 2, c = 3]
co[-"a", -"d"]                        # [b = 2, c = 3]

# Boolean
co[c(TRUE, FALSE, TRUE, FALSE)]      # [a = 1, c = 3]
co[TRUE, FALSE, TRUE, FALSE]         # same

# Partial boolean (recycling)
co[c(TRUE, FALSE)]                   # [a = 1, c = 3]
co[TRUE, FALSE]                      # same

# Mixed numeric and character
co[list(1, "d")]                     # [a = 1, d = 4]
co[1, "d"]                           # same

# Alpha-numeric ranges (non-standard evaluation)
co[a:b]                              # [a = 1, b = 2]
co[a:b, d:c]                         # [a = 1, b = 2, d = 4, c = 3]
co[1:c]                              # [a = 1, b = 2, c = 3]
co[d:2]                              # [d = 4, c = 3]

# Default values
co[1:5, 0, .default = 0]             # [a = 1, b = 2, c = 3, d = 4, 0]
co["a", "b", "z", .default = 0]      # [a = 1, b = 2, z = 0]
co[1:2, "z", .default = 3:4]         # [a = 1, b = 2, z = (3L 4L)]


co = container(a = 1, b = 2)
co[[1]]
co[["a"]]
co[["x"]]
}
