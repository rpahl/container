% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add.R, R/at.R, R/at2.R, R/clear.R, R/clone.R,
%   R/dict.table.R, R/discard.R, R/has.R, R/has_name.R, R/is_empty.R,
%   R/peek_at.R, R/peek_at2.R, R/rename.R, R/replace.R, R/update.R
\name{add.dict.table}
\alias{add.dict.table}
\alias{at.dict.table}
\alias{at2.dict.table}
\alias{clear.dict.table}
\alias{clone.dict.table}
\alias{dict.table}
\alias{as.dict.table}
\alias{as.dict.table.data.table}
\alias{is.dict.table}
\alias{as.data.table.dict.table}
\alias{rbind.dict.table}
\alias{cbind.dict.table}
\alias{discard.dict.table}
\alias{has.dict.table}
\alias{is_empty.dict.table}
\alias{peek_at.dict.table}
\alias{peek_at2.dict.table}
\alias{rename.dict.table}
\alias{replace.dict.table}
\alias{update.dict.table}
\title{dict.table}
\usage{
add(.x, ...)
add_(.x, ...)

at(.x, ...)

at2(x, index)

clear(x)
clear_(x)

clone(x, ...)

dict.table(...)

as.dict.table(x, ...)

\method{as.dict.table}{data.table}(x, copy = TRUE, ...)

is.dict.table(x)

\method{as.data.table}{dict.table}(x, copy = TRUE, ...)

\method{rbind}{dict.table}(x, ...)

\method{cbind}{dict.table}(x, ...)

discard(.x, ...)
discard_(.x, ...)

has(x, column)

has_name(x, name)

is_empty(x)

peek_at(.x, ..., .default = NULL)

peek_at2(x, index, default)

rename(.x, old, new, ...)
rename_(.x, old, new, ...)

replace(.x, key, value, add = FALSE)
replace_(.x, key, value, add = FALSE)

update(x, other)
update_(x, other)
}
\arguments{
\item{...}{further arguments passed to \code{\link[data.table:setattr]{data.table::setnames()}}}

\item{x}{any \code{R} object or a \code{dict.table} object.}

\item{copy}{if \code{TRUE} creates a copy of the \code{data.table} object otherwise
works on the passed object by reference.}

\item{name}{\code{character} the name to be found.}

\item{other}{another \code{dict.table} object}
}
\description{
The \code{\link[=dict.table]{dict.table()}} is a mix of a dictionary and a
\code{data.table}, that is, it can be considered as a dictionary with
all elements having the same length or as a data.table with extended
functionality to manage its data columns.
A dict.table object behaves like both a dict and a data.table, so that
all dict and data.table functions and operators are available.

As with \code{\link[=Dict]{Dict()}} objects, it provides reference semantics so that changes
like insertion and deletion of elements are done on the original object.
}
\details{
\itemize{
\item \code{add(.x, ...)} and add_(.x, ...) add columns to \code{.x}. If the column name
already exists, an error is given.
}

\itemize{
\item \code{at(.x, ...)} returns the columns at the given indices. Indices
can be letters or numbers or both. All columns must exist.
}

\itemize{
\item \code{at2(x, index)} returns the column at the given \code{index} or signals
an error if not found.
}

\itemize{
\item \code{clear(x)} and clear_(x) remove all elements from \code{x}.
}

\itemize{
\item \code{clone(x)} create a copy of \code{x}.
}

\itemize{
\item \code{discard(.x, ...)} and \code{discard_(.x, ...)} find and remove columns either by
name or index (or both). Columns that don't exist are ignored.
}

\itemize{
\item \code{has(x, column)} check if some \code{column} is in dict.table object.
}

\itemize{
\item \code{has_name(x, name)} check if \code{x} has the given column name.
}

\itemize{
\item \code{is_empty(x)} \code{TRUE} if object is empty otherwise \code{FALSE}
}

\itemize{
\item \code{peek_at(x, ..., .default = NULL)} returns the columns at the given
indices or (if not found) columns with the given default value.
}

\itemize{
\item \code{peek_at2(x, index, default)} return column named \code{index} if it exist
otherwise the given \code{default} value. If the default length does not match
the number of rows, it is recycled accordingly and a warning is given,
unless the default value has a length of 1, in which case recycling is
done silently.
}

\itemize{
\item \code{rename(.x, old, new)} and \code{rename_(.x, old, new)} rename one or more keys
from \code{old} to \code{new}, respectively, by copy and in place (i.e. by reference).
}

\itemize{
\item \code{replace(.x, key, value, add = FALSE)} and
\code{replace_(.x, key, value, add = FALSE)} replace values at column \code{key}.
If \code{key} does not exist, an error is given unless \code{add} was set to \code{TRUE}.
}

\itemize{
\item \code{update(x, other)} and \code{update_(x, other)} adds columns of \code{other} dict
that are not yet in \code{x} and replaces the values at existing columns.
}
}
\note{
In contrast to \code{\link[=data.table]{data.table()}}, \code{\link[=dict.table]{dict.table()}} does not allow duplicated keys.
}
\examples{

dit = dict.table(a = 1:3)
add(dit, b = 3:1, d = 4:6)

\dontrun{
add(dit, a = 7:9)  # column 'a' already exists}

dit = dict.table(a = 1:3, b = 4:6)
at(dit, "a")
at(dit, 2)
at(dit, "a", 2)
\dontrun{
at(dit, "x")     # index 'x' not found
at(dit, 1:3)     # index 3 exceeds length of dict.table}

dit = dict.table(a = 1:3, b = 4:6)
at2(dit, 1)
at2(dit, "a")
at2(dit, 2)
\dontrun{
at2(dit, "x")     # index 'x' not found
at2(dit, 5)       # index 5 exceeds length of dict.table}

dit = dict.table(a = 1, b = 2)
clear(dit)
dit
clear_(dit)
dit

d = dict.table(a = 1:2, b = 3:4)
clone(d)
# Some basic examples using some typical data.table and dict operations.
# The constructor can take the 'key' argument known from data.table():
dit = dict.table(x = rep(c("b","a","c"), each = 3), y = c(1,3,6), key = "y")
dit
setkey(dit, "x")                             # sort by 'x'
dit
(add(dit, "v", 1:9))                         # add column v = 1:9
dit[y > 5]
(discard(dit, "x"))                          # discard column 'x'
\dontrun{
    getval(dit, "x")                         # column 'x' does not exist
    setval(dit, "x", 0)                      # cannot be set, if not exist
}
(setval(dit, "x", 0, add = TRUE))            # ok - re-adds column 'x' with all 0s
peek(dit, "x")                               # glance at column 'x'
has(dit, "x")                                # TRUE
pop(dit, "x")                                # get column and remove it
has(dit, "x")                                # FALSE

# Copy and reference semantics when coercing *from* a data.table
dat = data.table(a = 1, b = 2)
dit = as.dict.table(dat)
is.dict.table(dit)                           # TRUE
is.dict.table(dat)                           # FALSE
setval(dit, "a", 9)
dit[["a"]]                                   # 9
dat[["a"]]                                   # 1
dit.dat = as.dict.table(dat, copy = FALSE)   # init by reference
setval(dit.dat, "a", 9)
dit.dat[["a"]]                               # 9
dat[["a"]]                                   # 9
is.dict.table(dit.dat)                       # TRUE
is.dict.table(dat)                           # TRUE now as well!

# Coerce from dict
d = dict(a = 1, b = 1:3)
as.dict.table(d)


Copy and reference semantics when coercing *to* a data.table
dit = dict.table(a = 1, b = 2)
dat = as.data.table(dit)
is.data.table(dat)                           # TRUE
data.table::set(dat, j = "a", value = 9)
dat[["a"]]                                   # 9
dit[["a"]]                                   # 1
dat.dit = as.data.table(dit, copy = FALSE)   # init by reference
is.data.table(dat.dit)                       # TRUE
is.dict.table(dit)                           # FALSE - not a dict.table anymore ...
is.data.table(dit)                           # TRUE  - ... but a data.table
data.table::set(dat.dit, j = "a", value = 9)
dat.dit[["a"]]                               # 9
dit[["a"]]                                   # 9 - also changed
dit = dict.table(a = 1:2, b = 1:2)
rbind(dit, dit)

dit = dict.table(a = 1:2, b = 1:2)
rbind(dit, dit)

# Also works with data.tables
dat = data.table(a = 3:4, b = 3:4)
rbind(dit, dat)  # yields a dict.table
rbind(dat, dit)  # yields a data.table
dit = dict.table(a = 1:2, b = 1:2)
dit2 = dict.table(c = 3:4, d = 5:6)
cbind(dit, dit2)

# Also works with data.tables
dit = dict.table(a = 1:2, b = 3:4)
rbind(dit, dit)

dit = as.dict.table(head(sleep))
discard(dit, "ID")
discard(dit, "ID", 1)
discard(dit, "foo")  # ignored

dit = dict.table(a = 1:3, b = as.list(4:6))
has(dit, 1:3)            # TRUE
has(dit, 4:6)            # FALSE
has(dit, as.list(4:6))   # TRUE

dit = dict.table(a = 1, b = 2)
has_name(dit, "a")    # TRUE
has_name(dit, 1)      # TRUE
has_name(dit, "x")    # FALSE
has_name(dit, 3)      # FALSE

d = dict.table(a = 1:4, b = 4:1)
is_empty(d)
is_empty(d$clear())

dit = dict.table(a = 1:3, b = 4:6)
peek_at(dit, "a")
peek_at(dit, 1)
peek_at(dit, 3)
peek_at(dit, "x")
peek_at(dit, "x", .default = 0)
peek_at(dit, "a", "x", .default = 0)

dit = dict.table(a = 1:3, b = 4:6)
peek_at2(dit, "a")
peek_at2(dit, 1)
peek_at2(dit, 3)
peek_at2(dit, 3, default = 9)
peek_at2(dit, "x")
peek_at2(dit, "x", default = 0)
dit = dict.table(a = 1, b = 2, c = 3)
(rename(dit, c("a", "b"), c("a1", "y")))
rename_(dit, c("a", "b"), c("a1", "y"))
print(dit)

dit = dict.table(a = 1:3)
replace(dit, "a", 3:1)
\dontrun{
replace(dit, "b", 4:6)               # column 'b' not in dict.table}
replace(dit, "b", 4:6, add = TRUE)   # ok, adds value
dit1 = dict.table(a = 1:2, b = 3:4)
dit2 = dict.table(         b = 5:6, c = 8:9)
update(d1, d2)
update(d2, d1)
}
\seealso{
\code{\link[=dict]{dict()}}, \code{\link[data.table:data.table]{data.table::data.table()}}
}
