% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add.R, R/clear.R, R/clone.R, R/delete.R,
%   R/dict.table.R, R/discard.R, R/get_at.R, R/has.R, R/is_empty.R, R/peek.R,
%   R/rename.R, R/replace.R, R/update.R
\name{add.dict.table}
\alias{add.dict.table}
\alias{clear.dict.table}
\alias{clone.dict.table}
\alias{delete.dict.table}
\alias{dict.table}
\alias{as.dict.table}
\alias{as.dict.table.data.table}
\alias{is.dict.table}
\alias{as.data.table.dict.table}
\alias{rbind.dict.table}
\alias{discard.dict.table}
\alias{get_at.dict.table}
\alias{has.dict.table}
\alias{is_empty.dict.table}
\alias{peek.dict.table}
\alias{rename.dict.table}
\alias{replace.dict.table}
\alias{update.dict.table}
\title{dict.table}
\usage{
add(.x, ...)
add_(.x, ...)

clear(x)
clear_(x)

clone(x, ...)

delete(.x, ...)
delete_(.x, ...)

dict.table(...)

as.dict.table(x, ...)

\method{as.dict.table}{data.table}(x, copy = TRUE, ...)

is.dict.table(x)

\method{as.data.table}{dict.table}(x, copy = TRUE, ...)

\method{rbind}{dict.table}(x, ...)

discard(.x, ...)
discard_(.x, ...)

get_at(.x, ...)

has(x, column)

is_empty(x)

peek(x, key, default)

rename(.x, old, new, ...)
rename_(.x, old, new, ...)

replace(.x, key, value, add = FALSE)
replace_(.x, key, value, add = FALSE)

update(x, other)
update_(x, other)
}
\arguments{
\item{...}{further arguments passed to \code{\link[data.table:setattr]{data.table::setnames()}}}

\item{x}{any \code{R} object or a \code{dict.table} object.}

\item{copy}{if \code{TRUE} creates a copy of the \code{data.table} object otherwise
works on the passed object by reference.}

\item{other}{another \code{dict.table} object}
}
\description{
The \code{\link[=dict.table]{dict.table()}} is a mix of a dictionary and a
\code{data.table}, that is, it can be considered as a dictionary with
all elements having the same length or as a data.table with extended
functionality to manage its data columns.
A dict.table object behaves like both a dict and a data.table, so that
all dict and data.table functions and operators are available.

As with \code{\link[=Dict]{Dict()}} objects, it provides reference semantics so that changes
like insertion and deletion of elements are done on the original object.
}
\details{
\itemize{
\item \code{add(.x, ...)} and add_(.x, ...) add columns to \code{.x}. If the column name
already exists, an error is given.
}

\itemize{
\item \code{clear(x)} and clear_(x) remove all elements from \code{x}.
}

\itemize{
\item clone(x) create a copy of \code{x}.
}

\itemize{
\item \code{delete(.x, ...)} and \code{delete_(.x, ...)} find and remove columns either by
name or index (or both). If one or more columns don't exist, an error is
signaled.
}

\itemize{
\item \code{discard(.x, ...)} and \code{discard_(.x, ...)} find and remove columns either by
name or index (or both). Columns that don't exist are ignored.
}

\itemize{
\item \code{get_at(.x, ...)} retrieves values at given columns specified either as
\code{numeric} or \code{character} name. If a column does not exist, an error is given.
}

\itemize{
\item \code{has(x, column)} check if some \code{column} is in dict.table object.
}

\itemize{
\item \code{is_empty(x)} \code{TRUE} if object is empty otherwise \code{FALSE}
}

\itemize{
\item \code{peek(x, key, default)} return column named \code{key} if it exist otherwise
the given \code{default} value. If the default length does not match the number
of rows, it is recycled accordingly and a warning is given, unless the
default value has a length of 1, in which case recycling is done silently.
}

\code{rename(.x, old, new)} and \code{rename_(.x, old, new)} rename one or more keys
from \code{old} to \code{new}, respectively, by copy and in place (i.e. by reference).

\itemize{
\item \code{replace(.x, key, value, add = FALSE)} and
\code{replace_(.x, key, value, add = FALSE)} replace values at column \code{key}.
If \code{key} does not exist, an error is given unless \code{add} was set to \code{TRUE}.
}

\itemize{
\item \code{update(x, other)} and \code{update_(x, other)} adds columns of \code{other} dict
that are not yet in \code{x} and replaces the values at existing columns.
}
}
\note{
In contrast to \code{\link[=data.table]{data.table()}}, \code{\link[=dict.table]{dict.table()}} does not allow duplicated keys.
}
\examples{

dit = dict.table(a = 1:3)
add(dit, b = 3:1, d = 4:6)

\dontrun{
add(dit, a = 7:9)  # column 'a' already exists}

dit = dict.table(a = 1, b = 2)
clear(dit)
dit
clear_(dit)
dit

d = dict.table(a = 1:2, b = 3:4)
clone(d)

dit = as.dict.table(head(sleep))
dit
delete(dit, "ID")
delete(dit, "ID", 1)
\dontrun{
delete(dit, "foo")   # Column 'foo' not in dict.table}
# Some basic examples using some typical data.table and dict operations.
# The constructor can take the 'key' argument known from data.table():
dit = dict.table(x = rep(c("b","a","c"), each = 3), y = c(1,3,6), key = "y")
dit
setkey(dit, "x")                             # sort by 'x'
dit
(add(dit, "v", 1:9))                         # add column v = 1:9
dit[y > 5]
(discard(dit, "x"))                          # discard column 'x'
\dontrun{
    getval(dit, "x")                         # column 'x' does not exist
    setval(dit, "x", 0)                      # cannot be set, if not exist
}
(setval(dit, "x", 0, add = TRUE))            # ok - re-adds column 'x' with all 0s
peek(dit, "x")                               # glance at column 'x'
has(dit, "x")                                # TRUE
pop(dit, "x")                                # get column and remove it
has(dit, "x")                                # FALSE

# Copy and reference semantics when coercing *from* a data.table
dat = data.table(a = 1, b = 2)
dit = as.dict.table(dat)
is.dict.table(dit)                           # TRUE
is.dict.table(dat)                           # FALSE
setval(dit, "a", 9)
dit[["a"]]                                   # 9
dat[["a"]]                                   # 1
dit.dat = as.dict.table(dat, copy = FALSE)   # init by reference
setval(dit.dat, "a", 9)
dit.dat[["a"]]                               # 9
dat[["a"]]                                   # 9
is.dict.table(dit.dat)                       # TRUE
is.dict.table(dat)                           # TRUE now as well!

# Coerce from dict
d = dict(a = 1, b = 1:3)
as.dict.table(d)


Copy and reference semantics when coercing *to* a data.table
dit = dict.table(a = 1, b = 2)
dat = as.data.table(dit)
is.data.table(dat)                           # TRUE
data.table::set(dat, j = "a", value = 9)
dat[["a"]]                                   # 9
dit[["a"]]                                   # 1
dat.dit = as.data.table(dit, copy = FALSE)   # init by reference
is.data.table(dat.dit)                       # TRUE
is.dict.table(dit)                           # FALSE - not a dict.table anymore ...
is.data.table(dit)                           # TRUE  - ... but a data.table
data.table::set(dat.dit, j = "a", value = 9)
dat.dit[["a"]]                               # 9
dit[["a"]]                                   # 9 - also changed
dit = dict.table(a = 1:2, b = 1:2)
rbind(dit, dit)

# Also works with data.tables
dat = dict.table(a = 3:4, b = 3:4)
dit.dat = rbind(dit, dat)

dit = as.dict.table(head(sleep))
discard(dit, "ID")
discard(dit, "ID", 1)
discard(dit, "foo")  # ignored

dit = dict.table(a = 1:3, b = 4:6)
get_at(dit, "b")
get_at(dit, "a", "b")    # or alternatively:
get_at(dit, c("a", "b"))

dit = dict.table(a = 1, b = 2)
has(dit, "a")    # TRUE
has(dit, 1)      # TRUE
has(dit, "x")    # FALSE
has(dit, 3)      # FALSE

d = dict.table(a = 1:4, b = 4:1)
is_empty(d)
is_empty(d$clear())

dit = dict.table(a = 1:3, b = 4:6)
peek(dit, "a")
peek(dit, 1)
peek(dit, 3)
peek(dit, "x")
peek(dit, "x", default = 0)
dit = dict.table(a = 1, b = 2, c = 3)
(rename(dit, c("a", "b"), c("a1", "y")))
rename_(dit, c("a", "b"), c("a1", "y"))
print(dit)

dit = dict.table(a = 1:3)
replace(dit, "a", 3:1)
\dontrun{
replace(dit, "b", 4:6)               # column 'b' not in dict.table}
replace(dit, "b", 4:6, add = TRUE)   # ok, adds value
dit1 = dict.table(a = 1:2, b = 3:4)
dit2 = dict.table(         b = 5:6, c = 8:9)
update(d1, d2)
update(d2, d1)
}
\seealso{
\code{\link[=dict]{dict()}}, \code{\link[data.table:data.table]{data.table::data.table()}}
}
