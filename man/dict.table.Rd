% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add.R, R/clear.R, R/clone.R, R/delete.R,
%   R/dict.table.R, R/discard.R, R/getval.R, R/has.R, R/is_empty.R, R/replace.R
\name{add.dict.table}
\alias{add.dict.table}
\alias{clear.dict.table}
\alias{clone.dict.table}
\alias{delete.dict.table}
\alias{delete_.dict.table}
\alias{dict.table}
\alias{as.dict.table}
\alias{as.dict.table.data.table}
\alias{is.dict.table}
\alias{as.data.table.dict.table}
\alias{rbind.dict.table}
\alias{discard.dict.table}
\alias{discard_.dict.table}
\alias{getval.dict.table}
\alias{has.dict.table}
\alias{is_empty.dict.table}
\alias{replace.dict.table}
\title{dict.table}
\usage{
add(x, ...)
add_(x, ...)

clear(x)
clear_(x)

clone(x, ...)

delete(x, ...)
delete_(x, ...)

dict.table(...)

as.dict.table(x, ...)

\method{as.dict.table}{data.table}(x, copy = TRUE, ...)

is.dict.table(x)

\method{as.data.table}{dict.table}(x, copy = TRUE, ...)

\method{rbind}{dict.table}(x, ...)

discard(x, ...)
discard_(x, ...)

getval(x, key)

has(x, column)

is_empty(x)

replace(x, key, value, add = FALSE)
replace_(x, key, value, add = FALSE)
}
\arguments{
\item{x}{any \code{R} object or a \code{dict.table} object.}

\item{...}{elements of the form \code{key = value} to be put into the
\code{dict.table} and/or additional arguments to be passed to the
\code{\link[data.table:data.table]{data.table::data.table()}} constructor.}

\item{copy}{if \code{TRUE} creates a copy of the \code{data.table} object otherwise
works on the passed object by reference.}

\item{key}{\code{character} or \code{numeric} vector of column names or indices}
}
\description{
The \code{\link[=dict.table]{dict.table()}} is a mix of a dictionary and a
\code{data.table}, that is, it can be considered as a dictionary with
all elements having the same length or as a data.table with extended
functionality to manage its data columns.
Basically a dict.table behaves like both a dict and a data.table, so that
all dict and data.table functions and operators are available.

As with \code{\link[=Dict]{Dict()}} objects, it provides reference semantics so that changes
like insertion and deletion of elements are done on the original object.
}
\details{
\itemize{
\item \code{add(x, ...)} and add_(x, ...) add columns to \code{x}. If the column name
already exists, an error is given.
}

\itemize{
\item \code{clear(x)} and clear_(x) remove all elements from \code{x}.
}

\itemize{
\item clone(x) create a copy of \code{x}.
}

\itemize{
\item \code{delete(x, ...)} and \code{delete_(x, ...)} find and remove columns either by
name or index (or both). If one or more columns don't exist, an error is
signaled.
}

\itemize{
\item \code{discard(x, ...)} and \code{discard_(x, ...)} find and remove columns either by
name or index (or both). If one or more columns don't exist, an error is
signaled.
}

\itemize{
\item \code{getval(x, key)} get value(s) at column(s) specified via \code{key}.
If a column does not exist, an error is given.
For a single column the raw column vector is
returned, otherwise a new \code{dict.table} object containing all requested columns.
\item \code{getvalues(x, ...)} is a convenience version of \code{getval(x, key)} enabling
to pass several keys (i.e. column names) separated by commas.
}

\itemize{
\item \code{has(x, column)} check if some \code{column} is in dict.table object.
}

\itemize{
\item \code{is_empty(x)} \code{TRUE} if object is empty otherwise \code{FALSE}
}

\itemize{
\item \code{replace(x, key, value, add = FALSE)} and \code{replace_(x, ...)} replace
values at column \code{key}. If \code{key} does not exist, an error is given unless
\code{add} was set to \code{TRUE}.
}
}
\note{
In contrast to \code{\link[=data.table]{data.table()}}, \code{\link[=dict.table]{dict.table()}} does not allow duplicated keys.
}
\examples{

dit = dict.table(a = 1:3)
add(dit, b = 3:1, d = 4:6)

\dontrun{
add(dit, a = 7:9)  # column 'a' already exists}

dit = dict.table(a = 1, b = 2)
clear(dit)
dit
clear_(dit)
dit

d = dict.table(a = 1:2, b = 3:4)
clone(d)

dit = as.dict.table(head(sleep))
dit
delete(dit, "ID")
delete(dit, "ID", 1)
\dontrun{
delete(dit, "foo")   # Column 'foo' not in dict.table}
discard(dit, "foo")  # ok - command is ignored
# Some basic examples using some typical data.table and dict operations.
# The constructor can take the 'key' argument known from data.table():
dit = dict.table(x = rep(c("b","a","c"), each = 3), y = c(1,3,6), key = "y")
dit
setkey(dit, "x")                             # sort by 'x'
dit
(add(dit, "v", 1:9))                         # add column v = 1:9
dit[y > 5]
(discard(dit, "x"))                          # discard column 'x'
\dontrun{
    getval(dit, "x")                         # column 'x' does not exist
    setval(dit, "x", 0)                      # cannot be set, if not exist
}
(setval(dit, "x", 0, add = TRUE))            # ok - re-adds column 'x' with all 0s
peek(dit, "x")                               # glance at column 'x'
has(dit, "x")                                # TRUE
pop(dit, "x")                                # get column and remove it
has(dit, "x")                                # FALSE

# Copy and reference semantics when coercing *from* a data.table
dat = data.table(a = 1, b = 2)
dit = as.dict.table(dat)
is.dict.table(dit)                           # TRUE
is.dict.table(dat)                           # FALSE
setval(dit, "a", 9)
dit[["a"]]                                   # 9
dat[["a"]]                                   # 1
dit.dat = as.dict.table(dat, copy = FALSE)   # init by reference
setval(dit.dat, "a", 9)
dit.dat[["a"]]                               # 9
dat[["a"]]                                   # 9
is.dict.table(dit.dat)                       # TRUE
is.dict.table(dat)                           # TRUE now as well!

# Coerce from dict
d = dict(a = 1, b = 1:3)
as.dict.table(d)


Copy and reference semantics when coercing *to* a data.table
dit = dict.table(a = 1, b = 2)
dat = as.data.table(dit)
is.data.table(dat)                           # TRUE
data.table::set(dat, j = "a", value = 9)
dat[["a"]]                                   # 9
dit[["a"]]                                   # 1
dat.dit = as.data.table(dit, copy = FALSE)   # init by reference
is.data.table(dat.dit)                       # TRUE
is.dict.table(dit)                           # FALSE - not a dict.table anymore ...
is.data.table(dit)                           # TRUE  - ... but a data.table
data.table::set(dat.dit, j = "a", value = 9)
dat.dit[["a"]]                               # 9
dit[["a"]]                                   # 9 - also changed
dit = dict.table(a = 1:2, b = 1:2)
rbind(dit, dit)

# Also works with data.tables
dat = dict.table(a = 3:4, b = 3:4)
dit.dat = rbind(dit, dat)

dit = dict.table(a = 1:3, b = 4:6)
getval(dit, "b")
getval(dit, c("a", "b"))
getvalues(dit, "a", "b")

dit = dict.table(a = 1, b = 2)
has(dit, "a")    # TRUE
has(dit, 1)      # TRUE
has(dit, "x")    # FALSE
has(dit, 3)      # FALSE

d = dict.table(a = 1:4, b = 4:1)
is_empty(d)
is_empty(d$clear())

dit = dict.table(a = 1:3)
replace(dit, "a", 3:1)
\dontrun{
replace(dit, "b", 4:6)               # column 'b' not in dict.table}
replace(dit, "b", 4:6, add = TRUE)   # ok, adds value
}
\seealso{
\code{\link[=dict]{dict()}}, \code{\link[data.table:data.table]{data.table::data.table()}}
}
