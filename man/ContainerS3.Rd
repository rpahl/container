% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/0-ContainerS3.R, R/0-IteratorS3.R,
%   R/GroupGenericMath.R, R/GroupGenericSummary.R, R/Ops-arithmetic.R,
%   R/Ops-compare.R, R/add.R, R/at.R, R/at2.R, R/clear.R, R/clone.R,
%   R/count.R, R/delete.R, R/delete_at.R, R/discard.R, R/discard_at.R, R/has.R,
%   R/has_name.R, R/is_empty.R, R/peek_at.R, R/peek_at2.R, R/pop.R, R/replace.R,
%   R/replace_at.R
\name{ContainerS3}
\alias{ContainerS3}
\alias{container}
\alias{as.container}
\alias{is.container}
\alias{as.list.Container}
\alias{length.Container}
\alias{names.Container}
\alias{iter.Container}
\alias{OpsMath}
\alias{OpsSummary}
\alias{+.Container}
\alias{-.Container}
\alias{==.Container}
\alias{ContainerS3methods}
\alias{add.Container}
\alias{at.Container}
\alias{at2.Container}
\alias{clear.Container}
\alias{clone.Container}
\alias{count.Container}
\alias{delete.Container}
\alias{delete_at.Container}
\alias{discard.Container}
\alias{has.Container}
\alias{has_name.Container}
\alias{is_empty.Container}
\alias{peek_at.Container}
\alias{peek_at2.Container}
\alias{pop.Container}
\alias{replace.Container}
\alias{replace_at.Container}
\title{Container methods}
\usage{
container(...)

as.container(x)

is.container(x)

\method{as.list}{Container}(x)

\method{length}{Container}(x)

\method{names}{Container}(x)

\method{iter}{Container}(x)

\method{+}{Container}(x, y)

\method{-}{Container}(x, y)

\method{==}{Container}(x, y)

## Container S3 methods

add(.x, ...)
ref_add(.x, ...)

at(.x, ...,)

at2(x, index)

clear(x)
ref_clear(x)

clone(x)

count(x)

delete(.x, ...)
ref_delete(.x, ...)

delete_at(.x, ...)
ref_delete_at(.x, ...)

discard(.x, ...)
ref_discard(.x, ...)

discard_at(.x, ...)
ref_discard_at(.x, ...)

has(x, elem)

has_name(x, name)

is_empty(x)

peek_at(x, ..., .default = NULL)

peek_at2(x, index, default)

ref_pop(.x, index)

replace(.x, old, new, add = FALSE)
ref_replace(.x, old, new, add = FALSE)

replace_at(.x, ..., .add = FALSE)
ref_replace_at(.x, ..., .add = FALSE)
}
\arguments{
\item{...}{(possibly named) elements to be put into or removed from the \code{Container}.}

\item{x, y}{\code{R} object of \code{ANY} type for \code{\link[=as.container]{as.container()}} and \code{\link[=is.container]{is.container()}}
or of class \code{Container} for the \code{S3} methods.}

\item{.x}{\verb{object of class }Container`}

\item{elem}{some element of any type}

\item{name}{\code{character} the name to be found.}

\item{index}{\code{character} name or \code{numeric} position of the sought value.}

\item{old}{old element to be found and replaced.}

\item{new}{the new element replacing the old one.}

\item{add}{\code{logical} if FALSE (default) and \code{old} element was not found,
an error is given. In contrast, if set to \code{TRUE} the new element is added
regardless of whether it is used as a replacement for an existing or
just as a new element, respectively.}

\item{.add}{\code{logical} if \code{FALSE} (default) and index is invalid, an error is
given. If set to \code{TRUE} the new element is added at the given index
regardless whether the index existed or not. Indices can consist of numbers
or names or both, except when adding values at nex indices, which is only
allowed for names.}
}
\description{
A \code{\link[=Container]{Container()}} is a data structure with typical member
functions to insert, delete and access elements from the container
object. The \code{\link[=Container]{Container()}} class serves as the base class for \code{\link[=Deque]{Deque()}},
'\code{\link[=Set]{Set()}}, and \code{\link[=Dict]{Dict()}} objects, which can be created by calls to
'\link[=Deque]{deque()}, \code{\link[=setnew]{setnew()}}, and \link[=Dict]{dict()}, respectively.
}
\details{
Methods that alter \code{Container} objects usually come in two versions
providing either copy or reference semantics where the latter are visible
by an underscore appended to the standard function name, for example,
\verb{[add()]} and \verb{[add_()]}.
\subsection{Methods}{
}

\itemize{
\item \code{container(...)} initializes and returns a \code{\link[=Container]{Container()}} object.
}

\itemize{
\item \code{as.container(x)} coerces \code{x} to a \code{container}
}

\itemize{
\item \code{is.container(x)} check if \code{x} is \code{container}
}

\itemize{
\item \code{as.list(x)} converts container \code{x} to a base \code{R} list. All of
the container's elements will copied (deeply) during the conversion.
}

\itemize{
\item \code{length(x)} returns the number of elements contained in \code{x}.
}

\itemize{
\item \code{names(x)} returns the names of the elements contained in \code{x}.
}

\itemize{
\item \code{x + y} combines \code{x} and \code{y} into a new container by appending \code{y}
to \code{x}.
}

\itemize{
\item \code{x - y} element-wise discards all items of \code{y} from \code{x}, given
the element was contained in \code{x}. The result is always a container.
}

\itemize{
\item \code{x == y} is \code{TRUE} if the contents of \code{x} and \code{y} are
lexicographically \emph{equal}.
}

\itemize{
\item \code{x != y} is \code{TRUE} if the contents of \code{x} and \code{y} are
not equal.
}

\itemize{
\item \code{x < y} is \code{TRUE} if the contents of x are lexicographically
\emph{less} than the contents of y.
}

\itemize{
\item \code{x <= y} is \code{TRUE} if the contents of x are lexicographically
\emph{less} than or \emph{equal} to the contents of y.
}

\itemize{
\item \code{add(.x, ...)} and \code{ref_add(.x, ...)} add elements to \code{.x}.
}

\itemize{
\item \code{at(.x, ...,)} returns the value at the given indices. Indices
can be letters or numbers or both. All indices must exist.
}

\itemize{
\item \code{at2(x, index)} returns the value at the given index or signals an error
if not found.
}

\itemize{
\item \code{clear(x)} and \code{ref_clear(x)} remove all elements from \code{x}.
}

\itemize{
\item \code{clone(x)} create a copy of \code{x}.
}

\itemize{
\item \code{count(x, elem)} count how often \code{elem} occurs in \code{x}.
}

\itemize{
\item \code{delete(.x, ...)} and \code{ref_delete(.x, ...)} find and remove elements.
If one or more elements don't exist, an error is signaled.
}

\itemize{
\item \code{delete_at(.x, ...)} and \code{ref_delete_at(.x, ...)} find and remove values at
given indices. If any given index is invalid, an error is signaled.
}

\itemize{
\item \code{discard(.x, ...)} and \code{ref_discard(.x, ...)} find and discard elements.
Elements that don't exist, are ignored.
}

\itemize{
\item \code{discard_at(.x, ...)} and \code{ref_discard_at(.x, ...)} find and discard values
at given indices. Invalid indices are ignored.
}

\itemize{
\item \code{has(x, elem)} \code{TRUE} if element is in \code{x} and otherwise \code{FALSE}.
}

\itemize{
\item \code{has_name(x, name)} check if \code{name} is in \code{x}
}

\itemize{
\item \code{is_empty(x)} \code{TRUE} if object is empty otherwise \code{FALSE}
}

\itemize{
\item \code{peek_at(x, ..., .default = NULL)} returns the value at the given indices
or (if not found) the given default value.
}

\itemize{
\item \code{peek_at2(x, index, default)} returns the value at the given index or (if
not found) the given default value.
}

\itemize{
\item \code{ref_pop(.x, index)} return element at given index and remove it
from the \code{container} object.
}

\itemize{
\item \code{replace(.x, old, new, add = FALSE)} and
\code{ref_replace(.x, old, new, add = FALSE)} try to find element \code{old} and
replace it with element \code{new}. If \code{old} does not exist, an error is raised,
unless \code{add} was set to \code{TRUE}.
}

\itemize{
\item \code{replace_at(.x, .., .add = FALSE)} and \code{ref_replace_at(.x, ..., .add = FALSE)}
replace values at given indices. If a given index is invalid, an error is
signaled unless \code{.add} was set to \code{TRUE}.
}
}
\examples{
co = container(1, b = NA, 1:3, c = container("a", 1))
is.container(co)
print(co)
length(co)
names(co)
as.list(co)
unpack(co)   # flatten recursively similar to unlist


# Math
set.seed(123)
co = as.container(rnorm(3))
abs(co)
cumsum(co)
round(co)
exp(co)

# Summary
range(co)
min(co)
max(co)

c1 = container(1, 1:2)
c2 = container(2, 1:2)
c1 + c2     # same as c(c1, c2)
c2 + c1     # same as c(c2, c1)

c1 - c2
c2 - c1
c1 - c1

c1 = container(1, 2, 3)
c2 = container(1, 3, 2)
c1 == c1            # TRUE
c1 != c2            # TRUE
c1 <= c1            # TRUE
c1 == c2            # FALSE
c1 < c2             # TRUE
c1 < container(2)   # TRUE
c1 < container()    # FALSE

co = container(1)
add(co, 1, b = 2, c = container(1:3))

co = container(a = 1, 2, b = 3, 4)
at(co, 1:3)
at(co, "a", "b", 2)
\dontrun{
at(co, "x")     # index 'x' not found
at(co, 1:10)    # index 5 exceeds length of Container}

co = container(a = 1, 2, b = 3, 4)
at2(co, 1)
at2(co, "a")
at2(co, 2)
\dontrun{
at2(co, "x")     # index 'x' not found
at2(co, 5)       # index 5 exceeds length of Container}

co = container(1, 2, mean)
clear(co)
print(co)    # Original was not touched
ref_clear(co)   # Clears original
print(co)

co = container(1, 2, 3)
co2 = clone(co)
co == co2

co = container("a", "b", "a", mean, mean)
count(co, "a")
count(co, mean)
count(co, "c")

co = container("a", 1:3, iris)
print(co)
delete(co, 1:3, "a")
delete(co, iris)
\dontrun{
delete(co, "b")   # "b" is not in Container}

co = container(a = 1, b = 2, 3)
delete_at(co, "a", "b")          # [3]
delete_at(co, 1:2)               # [3]
delete_at(co, "a", 3)            # [b = 2]
\dontrun{
delete_at(co, 4)                 # index out of range
delete_at(co, "x")               # names(s) not found: 'x'}

co = container("a", num = 1:3, data = iris)
print(co)
discard(co, 1:3, "a")
discard(co, iris)
discard(co, "b")  # ignored

co = container(a = 1, b = 2, 3)
discard_at(co, "a", "b")         # [3]
discard_at(co, 1:2)              # [3]
discard_at(co, "a", 3)           # [b = 2]
discard_at(co, "x")              # ignored

co = container(1, 2, mean)
has(co, 1)                   # TRUE
has(co, mean)                # TRUE
has(co, 1:2)                 # FALSE

co = container(a = 1, 2, f = mean)
has_name(co, "a")    # TRUE
has_name(co, "f")    # TRUE
has_name(co, "2")    # FALSE

co = container(1, 2)
is_empty(co)
is_empty(co$clear())

co = container(a = 1, 2, b = 3, 4)
peek_at(co, 1)
peek_at(co, "a")
peek_at(co, "x")
peek_at(co, "x", .default = 0)
peek_at(co, "a", "x", 2, 9, .default = -1)

co = container(a = 1, 2, b = 3, 4)
peek_at2(co, 1)
peek_at2(co, "a")
peek_at2(co, "x")
peek_at2(co, "x", default = 0)

co = container(a = 1, b = 1:3, d = "foo")
ref_pop(co, "b")
ref_pop(co, 1)

\dontrun{
ref_pop(co, "x")  # index 'x' not found}


co = container("x", 9)
replace(co, 9, 0)
replace(co, "x", 0)
\dontrun{
replace(co, "z", 0)              # old element ("z") is not in Container}
replace(co, "z", 0, add = TRUE)  # ok, adds the element

co = container(a = 0, b = "z")
replace_at(co, a = 1)
replace_at(co, 1, 1)                 # same
replace_at(co, "a", 1)               # same

\dontrun{
replace_at(co, x = 1)                # names(s) not found: 'x'}

replace_at(co, x = 1, .add = TRUE)   # ok (adds x = 1)
}
\seealso{
For the \code{Container} class documentation see \code{\link[=Container]{Container()}}. To
create objects of the derived classes see \code{\link[=deque]{deque()}}, \code{\link[=setnew]{setnew()}}, and
\code{\link[=dict]{dict()}}.
}
