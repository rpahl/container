---
title: "Overview and examples"
author: "Roman Pahl"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Container examples and methods overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview
The `Container` class serves as the base class for `Deque`, `Set` and `Dict`, which inherit all methods from `Container`, except those that are overwritten (see below). In addition, the `Container` and all its subclasses are iterable, that is, they provide a method returning an `Iterator` to iterate through the elements of the container object.
```{r out.width = '40%', echo = FALSE, fig.cap="Class diagram with basic class hierarchy."}
knitr::include_graphics("class-diagram-bare.png")
```


The following table shows member methods divided by class. The top half contains all `Container` methods, each derived by the subclasses to the right unless there is a new entry in a sub-class column, meaning the method is overwritten by the subclass.
The bottom half contains methods unique to each subclass.

|Iterable | Container                | Deque           | Set              | Dict                      |
|---------|--------------------------|-----------------|------------------|---------------------------|
|`iter()` |                          |                 |                  |                           |
|         | `add(elem)`              |                 | `add(elem)`      | `add(key, value)`         |
|         | `apply(f)`               |                 |                  |                           |
|         | `clear()`                |                 |                  |                           |
|         | `discard(elem, right=F)` |                 |                  | `discard(key)`            |
|         | `empty()`                |                 |                  |                           |
|         | `has(elem)`              |                 |                  | `has(key)`                |
|         | `print(list.len=10)`     |                 |                  |                           |
|         | `remove(elem, right=F)`  |                 |                  | `remove(key)`             |
|         | `size()`                 |                 |                  |                           |
|         | `type()`                 |                 |                  |                           |
|         | `values()`               |                 |                  |                           |
|         |                          |-----------------|------------------|---------------------------|
|         |                          | `addleft(elem)` | `union(s)`       | `get(key)`                |
|         |                          | `count(elem)`   | `intersect(s)`   | `keys()`                  |
|         |                          | `peek()`        | `diff(s)`        | `peek(key, default=NULL)` |
|         |                          | `peekleft()`    | `is.equal(s)`    | `pop(key)`                |
|         |                          | `pop()`         | `is.subset(s)`   | `popitem()`               |
|         |                          | `popleft()`     | `is.superset(s)` | `set(key, value)`         |
|         |                          | `reverse()`     |                  | `sort(decr=FALSE)`        |
|         |                          | `rotate(n=1L)`  |                  |                           |


Method descriptions are found in the respective online helps (see `?Container`, `?Deque`, `?Set`, and `?Dict`).

## Container examples
The base `Container` is ready to be used by itself. Examples of `Deque`, `Set`, and `Dict`, follow below.
```{r lib-setup}
library(container)
```

```{r}
collection <-  Container$new()
collection$empty()
```

#### add
By default, elements internally are stored in a basic `list` and therefore can be of any type.
```{r}
collection$add(1)
collection$add("A")
collection$add(data.frame(B=1, C=2))
collection$type()
```

The internal representation can always be retrieved directly using the `values` function.
```{r}
collection$values()
```

The container's print method presents the content more compact similar to `utils::str`
```{r}
collection$print()  # alternatively: print(collection)
```

If initialized with an R object, the type of the object is adopted to allow for efficient internal representations, if required.
```{r}
ints <- Container$new(integer())
ints$type()
```

The `add` method supports chaining.
```{r}
ints$add(1)$add(2)$add(3.7)$print()
```

Initialization also works with vectors.
```{r}
ints <- Container$new(1:10)$print()

ints$values()

ints$size()
```

#### discard, remove
```{r}
ints$has(11)

ints$has(7)

ints$discard(7)$has(7)

ints$remove(8)$has(8)
```

Using `remove` on non-existent elements throws an error,
```{r}
tryCatch(ints$remove(8), error = function(e) e$message)
```

but discard does not.
```{r}
ints$discard(8) # ok
```


Discard and remove work also from the right.
```{r}
ints$add(1:3)$values()

ints$discard(1)$values()

ints$discard(2, right=TRUE)$values()
```

#### apply
```{r}
unlist(ints$apply(f = function(x) x^2))

ints$clear()$empty()
```

More examples are found in the online help (see `?Container`).


### Reference semantics
Being based on R6 classes, any `Container` object provides reference semantics.
```{r}
members <- Container$new(c("Lisa", "Bob", "Joe"))$print()

remove_Joe <- function(cont) cont$discard("Joe")
remove_Joe(members)
members
```

#### Iterator
```{r}
it <- members$iter()
while(it$has_next()) print(it$get_next())
```

Once iterated to the last element, trying to iterate further leads to an error.
```{r}
tryCatch(it$get_next(), error = function(e) e$message)
```


## Deque
```{r}
d <- Deque$new(0L)
d$type()
d
```


#### addleft, count
```{r}
d$add(1)$add(2)$addleft(1)$addleft(2)$values()

d$count(0)  # count number of 0s

d$count(1)  # count number of 1s
```

#### peek, pop
A `peek` shows the last value, while `pop` shows and removes it afterwards. 
```{r}
d$peek()

d$pop()

d$pop()

d$values()
```

Being a double-ended queue, both methods are also defined for the left side.
```{r}
d$peekleft()

d$popleft()

d$values()

d$count(2)
```

Invoking `peek` on an empty `Deque` gives `NULL` while `pop` stops with an error.
```{r}
Deque$new()$peek()

tryCatch(Deque$new()$pop(), error = function(e) e$message)
```

#### rotate, reverse
```{r}
d$add(rep(0, 3))$values()

d$rotate()$values()    # rotate 1 to the right

d$rotate(2)$values()   # rotate 2 to the right

d$rotate(-3)$values()  # rotate 3 to the left

d$addleft(4:2)$values()

d$reverse()$values()
```

#### Deque iterator
Use iterator to re-add elements left and right into second `Deque` object.
```{r}
d2 <- Deque$new(integer())
it <- d$iter()
while(it$has_next()) {
    d2$add(it$get_next())
    if (it$has_next()) d2$addleft(it$get_next())
}
d2$values()
```

## Set
```{r}
s1 <- Set$new(1:3)$print()

s1$add(1)  # does not change the set 
s1
```

#### Set operations
```{r}
s1 <- Set$new(c(1, 2,    4, 5))
s2 <- Set$new(c(   2, 3,    5, 6))

s1$union(s2)$print()

s1$intersect(s2)$print()

s1$diff(s2)$print()

s1$is.subset(s2)
s1$is.subset(s1$union(s2))
s1$intersect(s2)$is.subset(s1)

s1$is.equal(s2)
s1$is.equal(s1)

s1$is.superset(s2)
s1$union(s2)$is.superset(s2)
```

## Dict
Due to the key-value semantic, several `Container ` methods are extended to take the key argument.
```{r}
ages <- Dict$new(c(Peter=24, Lisa=23, Bob=32))$print()

ages$add("Albert", 139)$values()

tryCatch(ages$add("Bob", 40), error = function(e) e$message)

ages$has("Peter")

ages$discard("Albert")$values()

# Trying to discard a non-existing key has no effect
ages$discard("Albert")$values()

# Trying to remove a non-existing key throws an error
tryCatch(ages$remove("Albert"), error = function(e) e$message)
```

#### More Dict-specific methods
```{r}
ages$keys()

ages$peek("Lisa")

ages$peek("Anna")
```

Trying to `set` a value at a non-existing key throws an error unless the `set` method is explicitly told to add it to the `Dict`.
```{r}
tryCatch(ages$set("Anna"), error = function(e) e$message)

ages$set("Anna", 23, add=TRUE)  # alternatively ages$add("Anna", 23)
ages
```

This allows fine control over the insert-behaviour of the `Dict`. If already existing, the value is overwritten.
```{r}
ages$set("Lisa", 11)$values()
```

A similar control is provided via the different methods to retrieve elements.
```{r}
ages$pop("Lisa")

ages$values()

tryCatch(ages$pop("Lisa"), error = function(e) e$message)

tryCatch(ages$get("Lisa"), error = function(e) e$message)

ages$peek("Lisa")
```

Finally, the `Dict` could also be used as a sampler (without replacement).
```{r}
set.seed(123)
while(!ages$empty()) {
    print(ages$popitem())
}
```


