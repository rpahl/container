---
title: "Smartly select and mutate data columns with dict.table"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Smartly select and mutate data columns with dict.table}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-setup, include = FALSE}
require(container)
require(dplyr)
library(microbenchmark)
library(ggplot2)
library(data.table)
library(tibble)


knitr::opts_chunk$set(
  comment = "#",
  prompt = F,
  tidy = FALSE,
  cache = FALSE,
  collapse = T,
  fig.width = 7
)

options(width = 100L)
```

## Motivation
The [dplyr](https://CRAN.R-project.org/package=dplyr) functions `select` and 
`mutate` are commonly applied to perform `data.frame` column operations,
frequently combined with [magrittr](https://CRAN.R-project.org/package=magrittr)s forward `%>%` pipe. While working well interactively, however, these methods often would require additional checking if used in "serious" code, for example, to catch column name clashes.

Since version 1.0.0, the [container](https://cran.r-project.org/web/packages/container/index.html)
package provides `dict.table`, which can be considered a
[data.table](https://CRAN.R-project.org/package=data.table) with
an extended set of functions to add, extract and remove data columns.
In this post I will show how and when they lead to faster and more precise
column operations than `mutate` and `select` and that all approaches can be 
easily combined.

To keep matters simple, we use a tiny data table.
```{r}
library(container)
library(dplyr)

data <- dict.table(x = c(0.2, 0.5), y = letters[1:2])
data
```

## Column operations
### Add
Let's add columns using `mutate`.
```{r}
n <- nrow(data)

data %>% 
    mutate(ID = 1:2, z = 1)
```

For someone not familar with the [tidyverse](https://www.tidyverse.org/), this code block might read somewhat odd as the column is added and *not* mutated. To add a column via `dict.table` simply use `add`.
```{r}
data %>% 
    add(ID = 1:2, z = 1)
```

The intended add-operation is stated more clearly. Next, instead of ID, let's add another numeric column `y`, which happens to "name-clash" with the already existing column.
```{r}
data %>% 
    mutate(y = 1)
```

Ooops - we have accidently overwritten the initial y-column. While this was easy to see here, it may not if the data has a lot of columns or if column names are created automatically as part of some script. To catch this, usually some overhead is required.
```{r, error=TRUE}
if ("y" %in% colnames(data)) {
    stop("column y already exists")
} else {
    data %>% 
        mutate(y = 1)
}
```

Let's see the `dict.table`-operation in comparison.
```{r, error=TRUE}
data %>% 
    add(y = 1)
```
The name clash is caught by default.

### Modify
If the intend was indeed to overwrite the value, the `dict.table` function `replace_at` can be used.
```{r}
data %>% 
    replace_at(y = 1)

# or programmatically
data %>% 
    replace_at("y", 1)
```

As we saw above, if a column does not exist, `mutate` silently creates it for you. If this is not what you want, which means, you want to make sure something is overwritten, again, a workaround is needed. 
```{r, error=TRUE}
if ("ID" %in% colnames(data)) {
    data %>% 
        mutate(ID = 1:2)    
} else {
    stop("column ID not in data.frame")
}
```

Once again, the workaround is already "built-in" in the `dict.table`-framework.
```{r, error=TRUE}
data %>% 
    replace_at(ID = 1:2)
```

After all, the intend of the `mutate` function actually would be something like: *overwrite a column or add it if it does not exist*. As you may already have guessed, this intend can also be expressed within the `dict.table`-framework.

```{r}
data %>% 
    replace_at(ID = 1:2, .add = TRUE)
```

### Remove
A common [tidyverse](https://www.tidyverse.org/) approach to remove a column is based on the `select` function. One corresponding `dict.table`-function is `delete`.
```{r}
data %>%
  select(-"y")

data %>% 
    delete_at("y")
```

Let's see what happens if the column does not exist in the first place.
```{r, error=TRUE}
data %>%
    select(-"ID")

data %>% 
    delete_at("ID")
```

So in this case, both frameworks will complain. Now assume we want the column to be removed if it exist but otherwise silently ignore the command, for example:
```{r}
if ("ID" %in% colnames(data)) {
    data %>%
        select(-"ID")    
}
```

The `dict.table` provides a straight-forward solution via the `discard` function:
```{r}
data %>% 
    discard_at("ID")
```

## Benchmark
To compare the performance of both frameworks, we benchmark some column 
operations using the standard 'cars' data set. As a hallmark reference we use [data.table](https://CRAN.R-project.org/package=data.table).


```{r}
library(microbenchmark)
library(ggplot2)
library(data.table)
library(tibble)

data = cars
head(cars)
```

For the benchmark, we add one, transform one and finally delete one column. 
```{r benchmark1, warning = FALSE, message = FALSE, cache=FALSE}
bm <- microbenchmark(control = list(order="inorder"), times = 100,
                     
    dict.table =
        as.dict.table(data) %>%
        add(time = .[["dist"]] / .[["speed"]]) %>%
        replace_at(dist = 0) %>%
        delete_at("speed"),
                     
    `data.table[` =
        as.data.table(data)[
        ][, time := dist / speed
        ][, dist := 0
        ][, speed := NULL],

    dplyr =
        as.tibble(data) %>% 
        mutate(time = dist / speed) %>%
        mutate(dist = 0) %>%
        select(-speed)
)
autoplot(bm) + theme_bw()
```

Apparently, `dict.table` and `data.table` performed nearly the same with
some distance to `dplyr` (about 10x). Let's examine each operation in more detail.

```{r benchmark2, warning = FALSE, message = FALSE, cache=FALSE}
data = cars
bm <- microbenchmark(control = list(order="inorder"), times = 100,

    dit <- as.dict.table(data),
    dit <- add(dit, time = dit[["dist"]] / dit[["speed"]]),
    dit <- replace_at(dit, dist = 0),
    dit <- delete_at(dit, "speed"),
                     
    dat <-  as.data.table(data),
    dat[, time := dist / speed],
    dat[, dist := 0],
    dat[, speed := NULL],

    tbl <- as.tibble(data),
    tbl <- mutate(tbl, time = dist / speed),
    tbl <- mutate(tbl, dist = 0),
    tbl <- select(tbl, -speed)
)
autoplot(bm) + theme_bw()
```

Apparently, the mutate and select operations are the slowest in comparison, 
which for the most part should be a result of the functions providing
non-standard evaluation (NSE) and other ways of input.
It's not surprising that such flexibility comes at a cost.

Since the
[data.table](https://CRAN.R-project.org/package=data.table) expressions also 
involve NSE terms and some overhead, in this benchmark the `dict.table` performs
even best. Having said that, of course, the [data.table](https://CRAN.R-project.org/package=data.table) code can be further improved by avoiding the overhead and instead use reference semantics via
`data.table`s built-in `set` function.

```{r benchmark3, warning = FALSE, message = FALSE, cache=FALSE}
data = cars
bm <- microbenchmark(control = list(order="inorder"), times = 100,

    dict.table = 
        as.dict.table(data) %>%
        add(time = dit[["dist"]] / dit[["speed"]]) %>%
        replace_at(dist = 0) %>%
        delete_at("speed"),
    
    ref_dict.table = 
        as.dict.table(data) %>%
        ref_add(time = .[["dist"]] / .[["speed"]]) %>%
        ref_replace_at(dist = 0) %>%
        ref_delete_at("speed"),
    
                     
    `data.table[` = 
        as.data.table(data)[
        ][, time := dist / speed
        ][, dist := 0
        ][, speed := NULL],
    
    set_data.table =
        as.data.table(data) %>%
        set(j = "ID", value = .[["dist"]] / .[["speed"]]) %>%
        set(j = "dist", value = 0) %>%
        set(j = "speed", value = NULL)
)

autoplot(bm) + theme_bw()
```

This puts things back into perspective. As you see we also provided a 
a reference semantic version of `dict.table`, which results in a slight 
speed improvement over the standard version. Overall, `data.table` remains the
way to go when speed is important.


## Summary
Accidentally overwriting existing data columns can lead to nasty bugs. The
`dict.table` framework allows to specify the intended column operations 
more clearly and thereby increases both reliability and precision of 
standard data column manipulation.

As a result, the `dict.table` framework may serve as a useful alternative when
writing semi-serious code, for example, in a scripted mid- to large data
analysis pipeline.

Last but not least, it is worth noting that `dict.table` is fully
compatible with `dplyr` and `data.table`, so the user is free to mix all
approaches in any order.

```{r}
res = data %>%
    as.dict.table %>%
    .[, time := dist / speed] %>%
    replace_at(dist = 0) %>%
    select(-speed)
```

Happy coding!
